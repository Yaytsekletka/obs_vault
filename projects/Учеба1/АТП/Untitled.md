Запомни два следующих скриптf
```
#!/bin/bash
# Шебанг: запуск этого скрипта через интерпретатор bash

if [ "$#" -ne 4 ]; then
  # Проверяем, что передано ровно 4 аргумента
  echo "Usage: $0 input.csv lower.csv upper.csv precision"
  # Сообщаем правильный синтаксис и выходим с кодом ошибки 1
  exit 1
fi

# Присваиваем аргументы понятным переменным
input_file="$1"   # имя входного CSV
lower_file="$2"   # файл для сохранения нижнетреугольной матрицы L
upper_file="$3"   # файл для сохранения верхнетреугольной матрицы U
prec="$4"         # точность (число знаков после запятой) при выводе

declare -A I       # ассоциативный массив для хранения исходной матрицы
row=0              # счётчик строк
ncols=0            # число столбцов (определится по первой строке)

# Читаем файл построчно, даже если последняя строка без перевода строки
while IFS= read -r line || [ -n "$line" ]; do
  # Разбиваем текущую строку по запятым в массив values
  IFS=',' read -ra values <<<"$line"

  if [ $row -eq 0 ]; then
    # Для первой строки устанавливаем число столбцов
    ncols=${#values[@]}
  fi

  # Сохраняем каждое значение в I[row,col]
  for ((col = 0; col < ncols; col++)); do
    I["$row,$col"]="${values[$col]}"
  done

  ((row++))  # переходим к следующей строке
done <"$input_file"

nrows=$row  # общее число строк
n=$nrows    # размер квадратной матрицы

declare -A L  # ассоциативный массив для нижнетреугольной матрицы
declare -A U  # ассоциативный массив для верхнетреугольной матрицы

# Основной двойной цикл для LU‑разложения
for ((i = 0; i < n; i++)); do

  # Считаем элементы U[i,j] для j>=i
  for ((j = i; j < n; j++)); do
    sum="0"
    # суммируем L[i,k]*U[k,j] по k от 0 до i-1
    for ((k = 0; k < i; k++)); do
      prod=$(echo "scale=10; ${L["$i,$k"]} * ${U["$k,$j"]}" | bc -l)
      sum=$(echo "scale=10; $sum + $prod" | bc -l)
    done
    # вычитаем сумму из исходного элемента
    U_val=$(echo "scale=10; ${I["$i,$j"]} - $sum" | bc -l)
    U["$i,$j"]="$U_val"
  done

  # Диагональный элемент L[i,i] по определению равен 1
  L["$i,$i"]="1"

  # Считаем элементы L[j,i] для j>i
  for ((j = i + 1; j < n; j++)); do
    sum="0"
    # суммируем L[j,k]*U[k,i] по k от 0 до i-1
    for ((k = 0; k < i; k++)); do
      prod=$(echo "scale=10; ${L["$j,$k"]} * ${U["$k,$i"]}" | bc -l)
      sum=$(echo "scale=10; $sum + $prod" | bc -l)
    done
    # рассчитываем L[j,i] как (I[j,i] - sum) / U[i,i]
    L_val=$(echo "scale=10; (${I["$j,$i"]} - $sum) / ${U["$i,$i"]}" | bc -l)
    L["$j,$i"]="$L_val"
  done

done

# Записываем матрицу L в CSV-файл с требуемой точностью
true >"$lower_file"   # очищаем (или создаём) файл lower_file
for ((i = 0; i < n; i++)); do
  line_out=""
  for ((j = 0; j < n; j++)); do
    # форматируем число L[i,j] с prec знаками после запятой
    formatted=$(printf "%.*f" "$prec" "${L["$i,$j"]}")
    if [ "$j" -eq 0 ]; then
      line_out="$formatted"
    else
      line_out="$line_out,$formatted"
    fi
  done
  echo "$line_out" >>"$lower_file"
done

# Записываем матрицу U в CSV-файл с требуемой точностью
true >"$upper_file"   # очищаем (или создаём) файл upper_file
for ((i = 0; i < n; i++)); do
  line_out=""
  for ((j = 0; j < n; j++)); do
    val="${U["$i,$j"]}"
    # если элемент U пуст (j<i), считаем его нулём
    if [ -z "$val" ]; then
      val="0"
    fi
    formatted=$(printf "%.*f" "$prec" "$val")
    if [ "$j" -eq 0 ]; then
      line_out="$formatted"
    else
      line_out="$line_out,$formatted"
    fi
  done
  echo "$line_out" >>"$upper_file"
done

exit 0  # успешное завершение скрипта
```
```
#!/bin/bash                              # Интерпретатор: использовать Bash

#echo "Starting..."                     # (отладка) показывать сообщение о начале работы

#count="$#"                             # (отладка) сохранить число аргументов в переменную

args=("$@")                             # Массив всех переданных аргументов

#echo "count of arguments: $count"     # (отладка) вывести число аргументов

limit=10                                # По умолчанию выводить 10 строк
order="up"                              # По умолчанию сортировать по убыванию (высокие значения первыми)
dir=""                                  # Переменная для директории
i=0                                     # Индекс для прохода по массиву args

# Цикл обработки опций и аргументов
while [[ $i -lt $# ]]; do
    case ${args[$i]} in
    -o | --order)                       # Если опция -o или --order
        order=${args[$((i + 1))]}      #   Сохраняем направление сортировки (up/down)
        ((i += 2))                     #   Пропускаем опцию и её значение
        ;;
    -l | --lines)                       # Если опция -l или --lines
        limit=${args[$((i + 1))]}      #   Сохраняем, сколько строк выводить
        ((i += 2))                     #   Пропускаем опцию и её значение
        ;;
    *)                                  # Всё остальное — считается директорией
        dir=${args[$i]}                #   Сохраняем имя директории
        ((i++))                        #   Переходим к следующему аргументу
        ;;
    esac
done

#echo -e "\nsettings"                  # (отладка) начать вывод параметров
#echo "dir: $dir"                      # (отладка) вывести директорию
#echo "lines: $limit"                  # (отладка) вывести число строк для вывода
#echo -e "order: $order\n"             # (отладка) вывести порядок сортировки

# Проверка существования директории
if [[ ! -d "$dir" ]]; then
    echo "Ошибка: директория '$dir' не существует."  # Сообщить об ошибке
    exit 1                                           # Завершить скрипт с кодом 1
fi

# Задаём регулярное выражение для поиска валидных строк в .log:
# [ УРОВЕНЬ ] ЧЧ:ММ:ГГГГ ЧИСЛО_СОБЫТИЯ ИМЯ_ПРОЦЕССА
regex="^\[ (INFO|DEBUG|WARNING|ERROR) \][[:space:]][0-9]{2}:[0-9]{2}:[0-9]{4}[[:space:]]([1-9][0-9]*|0)[[:space:]][a-zA-Z_]*$"

# Находим все .log-файлы, выбираем из них строки под regex, сортируем по 5-му полю (число),
# сохраняем в сортированный временный файл
find "$dir" -type f -name "*.log" -exec grep -E "$regex" {} \; \
    | sort -k5,5nr > sorted_logs.txt

# В зависимости от order выводим первые или последние limit строк
if [[ $order == "up" ]]; then
    head -n "$limit" sorted_logs.txt      # Первые limit строк (большие значения)
else
    tail -n "$limit" sorted_logs.txt      # Последние limit строк (меньшие значения)
fi

rm -f sorted_logs.txt                     # Удаляем временный файл
```


По ним и по вопросам из самого начала я буду тебя спрашивать 


Теор вопросы для устной защиты Блок 1. Linux Файловая система Linux. Файлы (их типы, назначение, расшифровка аббревиатур) /home, /proc, /opt, /usr, /etc, /bin, /lib, /boot, /dev, /sys, /tmp, /var, /dev/null, /dev/tty[0-9]* Файлы в Linux, их типы (все 7 штук), прочие характеристики. Разрешения и расширения файлов. Скрытые файлы. Создание различных типов файлов (-, d, l, p). Inode. Hard links VS symbolic links ~/.bashrc. Команды source, export Magic Bytes: Шебанг, ELF. Символ(ы) завершения строки: \r\n VS \n. Общий процесс работы shell интерпретатора: путь от строки с командой до запуска бинарного кода непосредственно. Переменные окружения. PATH, PWD, OLDPWD, IFS. Пользователи Linux, привилегированный пользователь. Группы пользователей. Смена разрешений, владельцев файла, группы владельцев. Мониторинг системы. Команды ps [aux], htop Архивы. Команды tar, gzip Блок 2. Bash Переменные: создание, изменение/получение значения Кавычки (‘, ”, `). Subshells. Комментарии. Heredoc` Индексированные и ассоциативные массивы: создание, обращение к элементам, размер массива, bash parameter expansion Циклы, ветвления, функции Чтение из stdin/файлов. Вывод в stderr/stdout/файл. Перезапись и дозапись. Pipe. Перенаправление stdin/stderr Базовые команды bash (их семантика и расшифровка): pwd, cd, ls, cp, mv, rm, cat, head, tail, sort Продвинутые команды bash (их семантика и расшифровка): xargs, find, tee, time, timeout Конструкции [] и [[]], $() и $(()), <<< и <() Команды cut, grep, wc, rev, tr, exit Аргументы скрипта. Количество аргументов, переменные $0, $1, $2, $3, .., $@. Как получить 10 аргумент через переменную? Команда shift. Возвращаемый код скрипта